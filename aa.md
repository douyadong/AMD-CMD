# 模块化理解

## 模块化的标准
1. CommonJs:是一个模块化的标准，Node.js在使用的一个模块化的标准;
2. AMD:Async Module Definition,在CommonJs基础上衍生出来的适用于前端开发中的模块化标准;(外国，尽早将所用的模块全部加载进来)(require.js)
3. CMD:Common Module Definition 也是在CommonJS基础上衍生出来的适用于前端开发中的模块化标准;(中国，用到的时候再加载)(sea.js)

## 模块化的实现(require.js)
1. require.js 只是一个js文件，可以帮助我们实现前端模块化;
2. 可以避免变量污染;
3. 引用js文件时，避免了引用次序出错造成的问题;
4. vue  angular项目就已经实现了模块化；

## 定义模块化 (无产出时)
```
例如在index.js文件里定义一个模块:
define(function(){
    console.log("模块化开发");
})
在js里引用:
require(["模块的名称即文件名(index)"]),require是加载某个mokuai;
```
## 定义模块化 (有产出时)
```
如果模块中需要将模块内的某些内容提供给应用该模块的地方使用，那么需要使用return语句，将要
提供的内容返回(second.js):
define(function(){
    var obj={
        k:"w"
    };
    return obj;
});
在引用模块的时候，如果模块有产出，有提供的内容给我们使用，那么需要在后面的回调函数中，写一个形参，来接收当前要加载的这个模块产出的内容;


```
## 模块依赖项的处理
```
如果定义一个模块的时候，这个模块要依赖于其他模块来实现，那么需要给这个模块指定依赖项;如果依赖的模块有产出，就在后面的函数里加上一个形参，注意顺需要对，一般将有产出的模块写在前面;
define(["模块名1","模块名2"],function(模块产出形参1，模块产出形参2){
    该模块的代码功能;
})
```
## 模块化的优势
```
1.可以将公共的部分定义成模块,方便服用;
2.解决全局变量污染的问题;
3.模块之间的依赖关系，非常明确，而且在应用模块的时候，根本不需要考虑依赖的先后顺序问题；
```
## requirejs可以通过config来配置一些内容;
```
引入requirejs之后，在script脚本里配置;
require.config({
    //所有模块的路径查找，都会以这个baseUrl指定的路径为基础;一般情况下就是找所有模块都能共享的目录,作为baseUrl;加载的时候不用写baseUrl，会自动加上;
    baseUrl:"",
    paths:{
        "某个模块别名":"详细路径"
        用于某个模块路径特别长，但是多个页面又都用到时，可以配置;加载模块的时候写上别名即可,查找的模块路径就是baseUrl+paths;
    }
})
```
## 判断第三方库是否支持模块化
```
1.如果第三方库代码中有
typeof define === "function" && define.amd时，代表该库支持模块化;
2.如果第三方库(可以是自己写的js，但是没用define，也可以是第三方插件)不支持模块化，而在使用require加载时，只是将这个第三方模块中的内容执行一遍，并不能帮助它实现依赖项的加载，也不能将模块的产出内容交给回调函数使用;
3.配置第三方模块另一种依赖方式，以及当第三方库不支持模块化时将其配置成支持模块化：
		//可以通过配置来实现给第三方非模块化的内容设置依赖项
		require.config({
			baseUrl: "/",
			paths: {
				"jquery": "assets/jQuery/jquery.min",
				"ani": "assets/animate/animate"
			},

			//可以通过shim为第三方非模块化的内容配置相关的依赖项等等...
			shim: {
				//属性名：第三方非模块内容的别名
				"ani": {
					//dependences： 要给这个模块加载的依赖项！
					deps: ["jquery"],
					//可以通过exports属性，为当前的非模块化内容，设置类似于模块化返回值的内容，  这里设置的是一个名字，requirejs会根据这个名字去非模块化的内容中查找和其同名的全局变量，最终将这个变量的值作为模块的产出，返回值使用！
					exports: "date"
				}
			}
		})

```
## 具名模块和匿名模块;
```
1.模块在声明的时候，给define传递的第一个参数可以是该模块的名称；
2.在config中配置的时候，别名尽量和具名模块的声明中的模块名称保持一致，这样可以保证不出错;
defint ("a",[],function(){

});
3.声明一个模块时尽量使用匿名模块;
require是加载并执行;
define是定义一个模块;
```
 